Exercise 1: Inventory Management System



Why Data Structures and Algorithms are Essential in Handling Large Inventories -

Data structures and algorithms are fundamental in managing large inventories because they determine how data is stored, organized, and accessed efficiently. With a large number of products, the choice of data structures and algorithms can significantly impact the performance of operations such as adding, updating, retrieving, and deleting inventory items. Efficient data management ensures quick response times, optimal use of memory, and scalability as the inventory grows.


Types of Data Structures Suitable for Inventory Management -

1. ArrayList (Dynamic Arrays):  Easy to implement, allows random access, and is suitable for scenarios where the number of items is relatively stable.

2. HashMap (Hash Table):

   Provides average O(1) time complexity for insertions, deletions, and lookups. Ideal for scenarios where quick access to items based on unique keys (e.g., productId) is required.
  
3. TreeMap (Red-Black Tree):

   Provides O(log n) time complexity for insertions, deletions, and lookups. Keeps the items sorted, which can be useful for range queries.
  

2. Setup

We will be creating a new project for the inventory management system and we will use Java for it.



       
 
For this implementation, we will use `HashMap` to store the products, with `productId` as the key for quick access.


import java.util.HashMap;
import java.util.Map;

public class InventoryManagementSystem {
    private Map<String, Product> inventory;

    public InventoryManagementSystem() {
        inventory = new HashMap<>();
    }

    public void addProduct(Product product) {
        inventory.put(product.getProductId(), product);
    }

    public void updateProduct(String productId, Product updatedProduct) {
        if (inventory.containsKey(productId)) {
            inventory.put(productId, updatedProduct);
        } else {
            System.out.println("Product not found.");
        }
    }

    public void deleteProduct(String productId) {
        if (inventory.containsKey(productId)) {
            inventory.remove(productId);
        } else {
            System.out.println("Product not found.");
        }
    }

    public Product getProduct(String productId) {
        return inventory.get(productId);
    }

    @Override
    public String toString() {
        return "InventoryManagementSystem [inventory=" + inventory + "]";
    }
}


 4. Analysis

Time Complexity of Each Operation

1. Add Product:
   - **Operation:** `addProduct()`
   - **Time Complexity:** O(1) on average because `HashMap` provides constant-time complexity for insertions.

2. Update Product:
   - **Operation:** `updateProduct()`
   - **Time Complexity:** O(1) on average because updating an element in a `HashMap` involves a constant-time lookup and insertion.

3. Delete Product:
   - **Operation:** `deleteProduct()`
   - **Time Complexity:** O(1) on average because `HashMap` provides constant-time complexity for deletions.

Optimization Suggestions

1. Hash Function Optimization: Ensure the hash function used for keys (productId) distributes entries uniformly across the hash table to minimize collisions and maintain constant-time complexity.

2. Load Factor Management: Adjust the load factor threshold of the `HashMap` to balance between time complexity and memory usage. A lower load factor reduces the likelihood of collisions but increases memory usage.

3. Concurrent Access: For a multi-threaded environment, consider using `ConcurrentHashMap` instead of `HashMap` to handle concurrent access efficiently.

4. Memory Optimization: Regularly monitor and optimize memory usage, especially if the inventory size grows significantly. Use appropriate data types and consider compressing data where feasible.

By carefully choosing and optimizing data structures and algorithms, you can ensure that the inventory management system remains efficient and scalable as the size of the inventory increases.